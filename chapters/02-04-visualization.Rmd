# Data Visualization {#Chap-02-02-visualization}

<hr>

<div style = "float:right; width:35%;">
<img src="visuals/badge-visualization.png" alt="badge-visualization">  
</div>  

Numerical summaries of complex data always incur information loss. Still lossy, but less so (if done well), is visualization. Any serious data analysis should start with a process in which the analyst becomes intimate with the data at hand. Visualization is an integral part of data-intimacy.

Section \@ref(Chap-02-04-Anscombe-example) demonstrates how summary statistics can be misleading and how a simple visualization can be much more revealing.
Section \@ref(Chap-02-04-good-visualization) offers some reflection on what makes a data visualization successful.
Section \@ref(Chap-02-04-ggplot) introduces the basics of data visualization with the `ggplot` package, an integral part of the tidyverse, based on a scatter plot for the [avocado price data](app-93-data-sets-avocado).
Going beyond scatter plots, section \@ref(Chap-02-04-geoms) looks at some common types of plots and how to realize them using the `geom_` family of functions in `ggplot`.


```{block, type='infobox'}
The learning goals for this chapter are:

- obtain a basic understanding of better/worse plotting
  - understand the idea of *hypothesis-driven visualization*
- develop a basic understanding of the 'grammar of graphs'
- get familiar with frequent visualization strategies
  - barplots, densities, violins, error bars etc.
- be able to fine-tune graphs for better visualization

```


## Motivating example: Anscombe's quartet {#Chap-02-04-Anscombe-example}

To see how summary statistics can be highly misleading, and how a simple plot can reveal a lot more, consider a famous dataset available in R [@anscombe1973]: 

```{r}
glimpse(anscombe %>% as_tibble)
```

There are four pairs of $x$ and $y$ coordinates. Unfortunately, these are stored in long format with two pieces of information buried inside of the column name: for instance, the name `x3` contains the information that this column contains the $x$ coordinates for the 3rd pair. This is rather untidy. But, using tools from the `dplyr` package, we can tidy up quickly:

```{r}
tidy_anscombe <- anscombe %>% as_tibble %>% 
  pivot_longer(
    ## we want to pivot every column
    everything(),
    ## use reg-exps to capture 1st and 2nd character
    names_pattern = "(.)(.)",      
    ## assign names to new cols, using 1st part of
    ##  what reg-exp captures as new column names
    names_to = c(".value", "grp")  
  ) %>% 
  mutate(grp = paste0("Group ", grp))
tidy_anscombe
```

Here are some summary statistics for each of the four pairs:

```{r}
tidy_anscombe %>% 
  group_by(grp) %>% 
  summarise(
    mean_x    = mean(x),
    mean_y    = mean(y),
    min_x     = min(x),
    min_y     = min(y),
    max_x     = max(x),
    max_y     = max(y),
    crrltn    = cor(x,y)
  )
```

<!-- EXERCISE: make the index the new column names instead -->

These numeric indicators suggest that each pair of $x$ and $y$ values is very similar. Only the ranges seem to differ. A brilliant example of how misleading numeric statistics can be, as compared to a plot of the data:^[It is not important to understand this code when you first read this chapter. But at the end of the chapter you should be able to understand (passively) what is going on here.]


```{r ch-02-anscombe, fig.cap="Anscombe's Quartet: four different data sets all of which receive the same correlation score."}
tidy_anscombe %>% 
  ggplot(aes(x, y)) +
    geom_smooth(method = lm, se = F, color = "darkorange") +
    geom_point(color = project_colors[3], size = 2) +
    scale_y_continuous(breaks = scales::pretty_breaks()) +
    scale_x_continuous(breaks = scales::pretty_breaks()) +
    labs(
      title = "Anscombe's Quartet", x = NULL, y = NULL,
      subtitle = bquote(y == 0.5 * x + 3 ~ (r %~~% .82) ~ "for all groups")
    ) +
    facet_wrap(~grp, ncol = 2, scales = "free_x") +
    theme(strip.background = element_rect(fill = "#f2f2f2", colour = "white"))
```

```{r, echo = F, eval = F}
save_last_plot("ch-02-04-anscombe")
```


<!-- for exercise check out the work of Jan Verhove: -->
<!-- https://janhove.github.io/teaching/2016/11/21/what-correlations-look-like -->


## Visualization: the good, the bad and the info-graphic {#Chap-02-04-good-visualization}

Producing good data visualization is very difficult. There are no uncontroversial criteria for what a good visualization should be. There are, unfortunately, quite clear examples of really bad visualizations. We will look at some of these examples in the following.

An absolute classic on data visualization is an early book by Edward @Tufte1983:The-Visual-Disp entitled "The Visual Display of Quantitative Information". A distilled and over-simplified summary of Tufte's proposal is that we should eliminate *chart junk* and increase the *data-ink ratio*, a concept which Tufte defines formally. The more information (=data) a plot conveys, the higher the data-ink ratio. The more ink it requires, the lower it is. 

However, not all information in the data is equally relevant. Also, spending extra ink to reduce the recipients mental effort of retrieving the relevant information can be justified. Essentially, I would here propose to consider a special case of data visualization, common to scientific presentations. I want to speak of **hypothesis-driven visualization** as a way of communicating a clear message, the message we care most about at the current moment of (scientific) exchange. Though merely a special instance of all the goals one could pursue with data visualization, focusing on this special case is helpful because it allows us to formulate a (defeasible) rule of thumb for good visualization in analogy to how natural language ought to be used in order to achieve optimal cooperative information flow (at least as conceived by authors such as ...)

```{block, type='infobox'}
**The vague & defeasible rule of thumb of good data visualization (according to the author).**

"Communicate a maximal degree of relevant true information in a way that minimizes the recipient's effort of retrieving this information."

```

Interestingly, just like natural language also needs to rely on a conventional medium for expressing ideas which might put additional constraints on what counts as optimal communication (e.g., we might not be allowed to drop a pronoun in English even though it is clearly recoverable from the context, and Italian speakers would happily omit it), so do certain unarticulated conventions in each specific scientific field.^[If your community only understands scatter plots and bar plots, it will not help communication but only mark you as a pompous show-off if you communicate in any other way, no matter how much better you think this is.]

Here are a few examples of bad plotting.^[For more disinspiration, see for example [this curated list of delightfully bad visualizations from actual publications](https://www.biostat.wisc.edu/~kbroman/topten_worstgraphs/).] To begin with, check out this fictitious data set:

```{r}
large_contrast_data <- tribble(
  ~group, ~treatment, ~measurement,
  "A",    "on",       1000,
  "A",    "off",      1002,
  "B",    "on",       992,
  "B",    "off",      990
)
```

If we are interested in any potential influence of variables `group` and `treatment` on the measurement in question, the following graph is ruinously unhelpful because the large size of the bars renders the relativly small differences between them almost entirely unspottable. 

```{r}
large_contrast_data %>% 
  ggplot(aes(x = group, y = measurement, fill = treatment)) +
  geom_bar(stat = "identity", position = "dodge")
```

A better visualization would be this:

```{r}
large_contrast_data %>% 
  ggplot(aes(
    x = group, 
    y = measurement, 
    shape = treatment, 
    color = treatment,
    group = treatment
    )
  ) +
  geom_point() +
  geom_line() +
  scale_y_continuous(breaks = scales::pretty_breaks())
```



The following examples use the [Bio-Logic Jazz-Metal data set](), in particular the following derived table of counts or the derived table of proportions:

```{r}
BLJM_associated_counts
```

It is probably hard to believe but Figure \@ref(fig:chap-02-04-bar-plot-3d-BLJM) was obtained without further intentional uglification just by choosing a default 3D bar plot display in Microsoft's Excel. It does actually show the relevant information but it is entirely useless for a human observer without a magnifying glass, professional measuring tools and a calculator.

```{r chap-02-04-bar-plot-3d-BLJM, echo = F, out.width='80%', fig.cap="Example of a frontrunner for the prize of today's most complete disaster in the visual communication of information."}
knitr::include_graphics("visuals/bar-plot-3D-BLJM.png")
```


It gets slightly better with the following pie chart of the same numerical information, also generated with Microsoft's Excel. Subjectively, Figure \@ref(fig:chap-02-04-pie-chart-BLJM) is pretty much anything but pretty. Objectively, it is better than the previous visualization in terms of 3D bar plots shown in Figure \@ref(fig:chap-02-04-bar-plot-3d-BLJM) but the pie chart is still not useful for answering the question which we care about, namely whether logicians are more likely to prefer Jazz over Metal than biologists.

```{r chap-02-04-pie-chart-BLJM, echo = F, out.width='80%', fig.cap="Example of a rather unhelpful visual representation of the BLJM data (when the research question is whether logicians are more likely to prefer Jazz over Metal than biologists)."}
knitr::include_graphics("visuals/pie-chart-BLJM.png")
```

We can produce a much more useful representation with the code below. (A similar visualization also appeared as Figure \@ref(fig:chap-02-03-BLJM-proportions) in the previous chapter.)

```{r chap-02-04-BLJM-proportions, echo = T}
BLJM_associated_counts %>% 
  ggplot(
    aes(
      x = LB, 
      y = n, 
      color = JM, 
      shape = JM, 
      group = JM
    )
  ) +
  geom_point(size = 3) + geom_line() +
  labs(
    title = "Counts of choices of each music+subject pair",
    x = "",
    y = ""
  )
```

<div class="infobox">
**Info-Graphics.** Scientific communication with visualized data is different from other modes of communcation with visualized data. These other contexts come with different requirements for good data visualization. Good examples of highly successful *info-graphics* are produced by the famous illustrator Nigel Holmes, for instance. Figure \@ref(fig:chap-02-04-vampire-energy) is an example from Holmes' website showing different amounts of energy consumption for different household appliances. The purpose of this visualization is not (only) to communicate information about which of the listed household appliances is most energy intensive. It's main purpose is to raise awareness for the unexpectedly large energy consumption of housefold appliances in general (in stand-by mode).^[Image retrieved from [Nigel Holmes' website](http://www.nigelholmes.com) website on November 25 2019.]

```{r chap-02-04-vampire-energy, echo = F, out.width='95%', fig.cap="Example of an infographic. While possibly considered 'chart junk' in a scientific context, the eye-catching and highly memorable (and pretty!) artwork serves a strong secondary purpose in contexts other than scientific ones where hypothesis-driven precise communication with visually presented data is key."}
knitr::include_graphics("visuals/vampire-energy.png")
```

</div>


## Basics of `ggplot` {#Chap-02-04-ggplot}

In this section we will work towards a first plot with `ggplot`. It will be a scatter plot (more on different kinds of plots in Section \@ref(Chap-02-04-geoms)) for the [avocado price data](app-93-data-sets-avocado). Check out the [ggplot cheat sheet](https://rstudio.com/wp-content/uploads/2015/03/ggplot2-cheatsheet.pdf) for a quick overview of the nuts and bolts of ggplot. 

The following introduces the key concepts of `ggplot`:

- **incremental composition**: adding elements or changing attributes of a plot incrementally
- **convenience functions & defaults**: a closer look at high-level convenience functions (like `geom_point`) and what they actually do
- **layers**: seeing how layers are stacked when we call, e.g. different `geom_` functions in sequence
- **grouping**: what happens when we use grouping information (e.g., for color, shape or in facets)

The section finishes with a first full example of plot that has different layers, uses grouping, and customizes a few other things.

### Incrementally composition of a plot

The "gg" in the package name `ggplot` is short for "grammar of graphs". It provides functions for describing scientific data plots in a compositional manner, i.e., for dealing with different recurrent elements in a plot in an additive way. As a results of this approach, we will use the symbol `+` to *add* more and more elements (or to override the implicit defaults in previously evoked elements) to build a plot. For example, we can obtain a scatter plot for the [avocado price data](app-93-data-sets-avocado) simply by first calling the function `ggplot`, which just creates an empty plot:

```{r}
incrementally_built_plot <- ggplot()
```

The plot stored in variable `incrementally_built_plot` is very boring. Take a look:

```{r}
incrementally_built_plot
```

As you can see, you do not see anything except a (white) canvas. But we can add some stuff. Don't get hung up on the details right now, just notice that we use `+` to add stuff to our plot:^[If you run this code for yourself, the output is likely to look different from what is shown here. This is because this web-book uses a default theme for all of its plots. We will come back to customization with themes later.]

```{r}
incrementally_built_plot + 
  # add a geom of type `point` (=> scatter plot)
  geom_point(
    # what data to use
    data = avocado_data, 
    # supply a mapping (in the form of an 'aesthetic' (see below))
    mapping = aes(
      # which variable to map onto the x-axis
      x = total_volume_sold,
      # which variable to map onto the y-axis
      y = average_price
      )
  )
```

You see that the function `geom_point` is what makes the points appear. You tell it which data to use and which mapping of variables from the data set to elements in the plot you like. That's it, at least to begin with.

We can also supply the information about the data to use and the aesthetic mapping in the call to function `ggplot`. Doing so will make this information the default for any subsequently added layer. Notice also that the `data` argument in function `ggplot` is the first argument, so we will frequently make use of piping, like in the following code which is equivalent to the previous in terms of output:

```{r}
avocado_data %>% 
  ggplot(aes(x = total_volume_sold, y = average_price)) +
  geom_point()
```

```{r, eval = F, echo =F }
save_last_plot("ch-02-04-avocado-basic")
```

### Elements in the layered grammar of graphs

Let's take a step back. Actually, the function `geom_point` is a convenience function that does a lot of things automatically for us. It helps understanding subsequent code if we peak under the hood at least for a brief moment initially, if only to just realize where some of the terminology in and round the "grammar of graphs" comes from. 

The `ggplot` package defines a **layered grammar of graphs** [@Wickham2010:A-Layered-Gramm]. This is a structured description language for plots (relevant for data science). It uses a smart system of defaults so that it suffices to often just call a convenience wrapper like `geom_point`. But underneath there is the possibility of tinkering with (almost?) all of the (layered) elements and to change the defaults if need be. 

The process of mapping data onto a visualization essentially follows this route:

> data -> statistical transformation -> geom. object -> aesthetics

You supply (tidy) data. The data is then transformed (e.g., by computing a summary statistic) in some way or another. This could just be an "identity map" in which case you will visualize the data exactly as it is. The resulting data representation is mapped onto some spatial (geometric) appearance, like a line, a dot, or a geometric shape. Finally, there is room to alter the specific aesthetics of this mapping from data to visual object, like adjusting the size or the color of a geometric object, possibly depending on some other properties it has (e.g., whether it is an observation for a conventional or an organically grown avocado).

To make explicit the steps which are implicitly carried out by `geom_points` in the example above, here is a fully verbose but output-equivalent sequence of commands that builds the same plot by defining all the basic components manually:
    

```{r}
avocado_data %>% 
ggplot() +
  # plot consists of layers (more on this soon)
  layer(
    # how to map columns onto ingredients in the plot
    mapping = aes(x = total_volume_sold, y = average_price),
    # what statistical transformation should be used? - here: none
    stat = "identity",
    # how should the transformed data be visually represented? - here: as points
    geom = "point",
    # should we tinker in any other way with the positioning of each element?
    # - here: no, thank you!
    position = "identity"
  ) +
  # x & y axes are non-transformed continuous
  scale_x_continuous() +
  scale_y_continuous() +
  # we use a cartesian coordinate system (not a polar or a geographical map)
  coord_cartesian()
```  

In this explicit call, we still need to specify the data and the mapping (which variable to map onto which axis). But we need to specify much more. We tell `ggplot` that we want standard (e.g., not log-transformed axis). We also tell it that our axis are continuous, that the data should not be transformed and that the visual shape (=geom) to which the data is to be mapped is a point (hence the name `geom_point`).

It is not important to understand all of these components right now. It is important to have seen them once, and to understand that `geom_point` is a wrapper around this call which assumes reasonable defaults (such as non-transformed axis, points for representation etc.).

### Layers and groups

`ggplot` is the "grammar of *layered* graphs". Plots are compositionally built by combining different layers, if need be. For example, we can use another function from the `geom_` family of functions to display a different visualization derived from the same data on top of our previous scatter plot.^[Notice that, as soon as we add the linear regression line, it makes sense to use the logarith of the `total_volume_sold` because otherwise the fit is quite ridiculous. The logarithm helps to spread out the large number of data points where `total_volume_sold` is very low, and to "bring back to the flock" the data points where the `total_volume_sold` is outliery high. It can be quite useful to use such transformations, if they are well understood. It is controversial whether such transformations should precede statistical analyses, but that is not important right now.] 

```{r}
avocado_data %>% 
  ggplot(
    mapping = aes(
      # notice that we use the log (try without it to understand why)
      x = log(total_volume_sold),
      y = average_price
    )
  ) +
  # add a scatter plot
  geom_point() +
  # add a linear regression line
  geom_smooth(method = "lm")
```

Notice that layering is really sequential. To see this, just check what happens when we reverse the calls of the `geom_` functions in the previous example:

```{r}
avocado_data %>% 
  ggplot(
    mapping = aes(
      # notice that we use the log (try without it to understand why)
      x = log(total_volume_sold),
      y = average_price
    )
  ) +
  # FIRST: add a linear regression line
  geom_smooth(method = "lm") +
  # THEN: add a scatter plot
  geom_point()
```

If you want lower layers to be visible behind layers added later, one possibility is to tinker with opacity, via the `alpha` parameter. Notice that the example below also changes the colors. The result is quite toxic, but at least you see the line underneath the semi-transparent points.

```{r}
avocado_data %>% 
  ggplot(
    mapping = aes(
      # notice that we use the log (try without it to understand why)
      x = log(total_volume_sold),
      y = average_price
    )
  ) +
  # FIRST: add a linear regression line
  geom_smooth(method = "lm", color = "darkgreen") +
  # THEN: add a scatter plot
  geom_point(alpha = 0.1, color = "orange")
```

The aesthetics defined in the initial call to `ggplot` are global defaults for all layers to follow, unless they are overwritten. This also holds for the data supplied to `ggplot`. For example, we can create a second layer using another call to `geom_point` from a second data set (e.g., with a summary statistic), like so:

```{r}
# create a small tibble with the means of both
#   variables of interest
avocado_data_means <- 
  avocado_data %>% 
  summarize(
    mean_volume = mean(log(total_volume_sold)),
    mean_price  = mean(average_price)
  )
avocado_data_means
```

```{r}
avocado_data %>% 
  ggplot(
    aes(x = log(total_volume_sold),
        y = average_price)
  ) +
  # first layer uses globally declared data & mapping
  geom_point() +
  # second layer uses different data set & mapping
  geom_point(
    data = avocado_data_means,
    mapping = aes(
      x = mean_volume,
      y = mean_price
    ), 
    # change shape of element to display (see below)
    shape = 9,
    # change size of element to display
    size = 12,
    color = "skyblue"
  )
```


### Grouping 

Categorical distinction are frequently important in data analysis. Just think of the different combinations of factor levels in a factorial design, or the difference between conventionally grown and organically grown avocados. `ggplot` understands grouping very well and acts on appropriately, if you tell it to in the right way.

Grouping can be relevant for different aspects of a plot: the color of points or lines, their shape, or even whether to plot everything together or separately. For instance, we might want to display different types of avocados in different color. We can do this like so:

```{r}
avocado_data %>% 
  ggplot(
    aes(
      x = log(total_volume_sold), 
      y = average_price,
      # use a different color for each type of avocado
      color = type
    )
  ) +
  geom_point(aes(color = type))  
```

Notice that we added the grouping information inside of `aes` to the call of `ggplot`. This way the grouping is the global defaul for the whole plot. Check what happens when we then add another layer, like `geom_smooth`: 

```{r}
avocado_data %>% 
  ggplot(
    aes(
      x = log(total_volume_sold), 
      y = average_price,
      # use a different color for each type of avocado
      color = type
    )
  ) +
  geom_point(aes(color = type))  + 
  geom_smooth(method = "lm")
```

The regression lines will also be shown in the colors of the underlying scatter plot. We can change this by overwriting the `color` attribute locally, but then we loose the grouping information:


```{r}
avocado_data %>% 
  ggplot(
    aes(
      x = log(total_volume_sold), 
      y = average_price,
      # use a different color for each type of avocado
      color = type
    )
  ) +
  geom_point(aes(color = type))  + 
  geom_smooth(method = "lm", color = "black")
```

To retrieve the grouping information, we can change the explicit keyword `group` (which just treats data from the relevant factor levels differently without directly changing their appearance):

```{r}
avocado_data %>% 
  ggplot(
    aes(
      x = log(total_volume_sold), 
      y = average_price,
      # use a different color for each type of avocado
      color = type
    )
  ) +
  geom_point(aes(color = type))  + 
  geom_smooth(
    # tell the smoother to deal with avocados types separately
    aes(group = type),
    method = "lm", 
    color = "black"
  )
```

Finally, we see that the lines are not uniquely associable with the avocado type, so we can also change the regression line's `shape` attribute conditional on avocado type:

```{r}
avocado_data %>% 
  ggplot(
    aes(
      x = log(total_volume_sold), 
      y = average_price,
      # use a different color for each type of avocado
      color = type
    )
  ) +
  geom_point(aes(color = type))  + 
  geom_smooth(
    # tell the smoother to deal with avocados types separately
    aes(group = type, linetype = type),
    method = "lm", 
    color = "black"
  )
```

### Example of a customized plot

If done with the proper mind and heart, plots intended to share (and to communicate a point, following the idea of hypothesis-driven visualization) will usually require a lot of tweaking. We will cover some of the most frequently relevant tweaks in Section \@ref(Chap-02-04-customization).

To nevertheless get a feeling of where the journey is going, at least roughly, here is an example of a plot of the avocado data which is much more tweaked and honed. No claim is intended regarding the false idea that this plot is in any sense optimal. There is not even a clear hypothesis or point to communicate. This just showcases some functionality. Notice, for instance, that this plot uses two layers, invoked by `geom_point` which shows the scatter plot of points and `geom_smooth` which layers on top the point cloud regression lines (one for each level in the grouping variable).

```{r}
# pipe data set into function `ggplot`
avocado_data %>% 
  # reverse factor level so that horizontal legend entries align with
  # the majority of observations of each group in the plot
  mutate(
    type = fct_rev(type)
  ) %>% 
  # initialize the plot
  ggplot(
    # defined mapping
    mapping = aes(
      # which variable goes on the x-axis
      x = total_volume_sold, 
      # which variable goes on the y-axis
      y = average_price, 
      # which groups of variables to distinguish
      group = type, 
      # color and fill to change by grouping variable
      fill = type, 
      linetype = type,
      color = type
    )
  ) +
  # declare that we want a scatter plot
  geom_point(
    # set low opacity for each point
    alpha = 0.1
  ) +
  # add a linear model fit (for each group)
  geom_smooth(
    color = "black", 
    method = "lm"
  ) +
  # change the default (normal) of x-axis to log-scale
  scale_x_log10() +
  # add dollar signs to y-axis labels
  scale_y_continuous(labels = scales::dollar) +
  # change axis labels and plot title & subtitle
  labs(
    x = 'Total volume sold (on a log scale)',
    y = 'Average price',
    title = "Avocado prices against amount sold",
    subtitle = "With linear regression lines"
  )
```

```{r,  eval  = F, echo = F}
save_last_plot("ch-02-04-avocado-final")
```

<!-- exercise 1 -->
<div class = "exercises">
**Exercise E.1: Some algebra**

Determine which graph was created with which code: 

Code 1:
```{r}

code_1 <- ggplot(avocado_data,
    mapping = aes(
      x = average_price,
      y = log(total_volume_sold), 
      color = type
    )
  ) +
  geom_point()+
  geom_smooth(method = "lm")
```

Code 2: 
```{r}

code_2 <-ggplot(avocado_data,
    mapping = aes(
      x = log(total_volume_sold),
      y = average_price,
      color = type
    )
  ) +
  geom_point()+
  geom_smooth(method = "lm")
```

Code 3:
```{r}

code_3 <- ggplot(avocado_data,
    mapping = aes(
      x = log(total_volume_sold),
      y = average_price
    )
  ) +
  geom_smooth(method = "lm", color = "black") +
  geom_point(alpha = 0.1, color = "blue")+
   labs(
    x = 'Total volume sold (on a log scale)',
    y = 'Average price',
    title = "Avocado prices against amount sold"
  )
```

Code 4: 
```{r}

code_4 <- ggplot(avocado_data,
    mapping = aes(
      x = log(total_volume_sold),
      y = average_price,
      linetype = type
    )
  ) +
  geom_smooth(method = "lm", color = "black") +
  geom_point(alpha = 0.1, color = "blue")+
   labs(
    x = 'Total volume sold (on a log scale)',
    y = 'Average price',
    title = "Avocado prices against amount sold"
  )
```

Plot 1: 
```{r, echo=FALSE}
#PLot1
#Code 4
code_4 + annotate("text", x = 15, y = 3, label = "Plot 1", color = "red")
```

Plot 2:
```{r, echo=FALSE}
#Plot2
#Code 1
code_1 + annotate("text", x = 3, y = 16, label = "Plot 2", color = "red")
```

Plot 3:
```{r, echo=FALSE}
#Plot3
#Code 2
code_2 + annotate("text", x = 15, y = 3, label = "Plot 3", color = "red")
```


<div class="collapsibleSolution">
<button class="trigger">Solution</button>
<div class="content">
<p> Plot 1: Code 4 </p>
<p> Plot 2: Code 1 </p>
<p> Plot 3: Code 2 </p>
</div>
</div>
</div>


## A rendezvous with popular geoms {#Chap-02-04-geoms}

In the following we will cover some of the more basic `geom_` functions relevant for our present purposes. It might be useful to read this section top-to-bottom at least once, not to think of it as a mere reference list. More information is provided by the [ggplot cheat sheet](https://rstudio.com/wp-content/uploads/2015/03/ggplot2-cheatsheet.pdf). 

### Scatter plots with `geom_point`

Scatter plots visualize pairs of associated observations as points in space. We have seen this for the avocado prize data above. Let's look at some of the further arguments we can use to tweak the presentation by `geom_point`. The following example changes the shape of the objects displayed to tilted rectangles (sometimes called diamonds, e.g., in LaTeX `\diamond`) away from the default circles, the color of the shapes, their size and opacity.

```{r}
avocado_data %>% 
  ggplot(aes(x = log(total_volume_sold), y = average_price)) +
  geom_point(
    # shape to display is number 23 (tilted rectangle, see below)
    shape = 23,
    # color of the surrounding line of the shape (for shapes 21-24)
    color = "darkblue",
    # color of the interior of each shape
    fill = "lightblue",
    # size of each shape (default is 1)
    size = 5,
    # level of opacity for each shape
    alpha = 0.3
  )
```

How do you know which shape is which number? - By looking at the picture in Figure \@ref(fig:02-04-ggplot-shapes), for instance.

```{r 02-04-ggplot-shapes, echo = F, fig.cap="The numerical coding of different shapes in `ggplot` Notice that objects 21-24  are sensitive to both `color` and `fill`, but the others are only sensitive to `color`."}
knitr::include_graphics("visuals/ggplot-shapes.png")
```


### Smooth

The `geom_smooth` function operates on two-dimensional metric data and outputs a smoothed line, using different kinds of fitting functions. It is possible to show an indicator of certainty for the fit. We will deal with model fits in later parts of the book. For illustration just enjoy a few examples here:

```{r}
avocado_data %>% 
  ggplot(aes(x = log(total_volume_sold), y = average_price)) +
  geom_point(
    shape = 23,
    color = "darkblue",
    fill = "lightblue",
    size = 3,
    alpha = 0.3
  ) + 
  geom_smooth(
    # fitting a smoothed curve to the data
    method = "loess",
    # display standard error around smoothing curve 
    se = T,
    color = "darkorange"
    )
```


### Line

Use `geom_line` to display a line for your data if that data has associated (ordered) metrix values. You can use argument `linetype` to specify the kind of line to draw.

```{r}
tibble(
  x = seq(-4,8, by = 2),
  y = x^2
) %>% 
  ggplot(aes(x,y)) +
  geom_line(
    linetype = "dashed"
  )
```

Sometimes you may want to draw lines between items that are grouped:

```{r}
BLJM_associated_counts %>% 
  ggplot(
    aes(
      x = LB, 
      y = n, 
      color = JM,
      group = JM
    )
  ) +
  geom_line(size = 3)
```


### Barplot

A barplot, plotted with `geom_bar` or `geom_col`, displays a single number for each of several groups for visual comparison by length. The difference between these two functions is that `geom_bar` relies on an implicit counting, while `geom_col` expects the numbers that translate into the length of the bars to be supplied for it. This book favors the use of `geom_col` by first wrangling the data to show the numbers to be visualized, since often this is the cleaner approach and the numbers are useful to have access to independently (e.g., for referring to in the text).

Here's an example of how `bar_plot` works (implicitly counting numbers of occurrences):

```{r}
tibble(
  shopping_cart = c(
    rep("chocolate", 2),
    rep("ice-cream", 5),
    rep("cookies",8)
  )
) %>% 
  ggplot(aes(x = shopping_cart)) +
  geom_bar()
```

To display this data with `geom_col` we need to count occurrences first ourselves:

```{r}
tibble(
  shopping_cart = c(
    rep("chocolate", 2),
    rep("ice-cream", 5),
    rep("cookies",8)
  ) 
) %>% 
  dplyr::count(shopping_cart) %>% 
    ggplot(aes (x = shopping_cart, y = n) ) +
    geom_col()
```

To be clear, `geom_col` is essentially `geom_bar` when we overwrite the default statistical transformation of counting to "identity":

```{r}
tibble(
  shopping_cart = c(
    rep("chocolate", 2),
    rep("ice-cream", 5),
    rep("cookies",8)
  ) 
) %>% 
  dplyr::count(shopping_cart) %>% 
    ggplot(aes (x = shopping_cart, y = n) ) +
    geom_bar(stat = "identity")
```

Barplots are a frequent sight in psychology papers. They are also controversial. They often fare badly with respect to the data-ink ratio. Especially, when what is plotted are means of grouped variables. For example, the following plot is rather uninformative (even if the research question is a comparison of means):

```{r}
avocado_data %>% 
  group_by(type) %>% 
  summarise(
    mean_price = mean(average_price)
  ) %>% 
  ggplot(aes(x = type, y = mean_price)) +
  geom_col()
```

It makes sense to use the available space for a more informative report about the distribution of data points around the means, e.g., by using `geom_violin` or `geom_histogram` etc.

But barplots may also be good enough if there is not more of immediate relevance, such as when we look at counts or proportions. Still, it might help to include a measure of certainty. For instance, using the King of France data set, we can display proportions of 'true' answers with 95% bootstrapped confidence intervals like in the plot below. Notice the use of the `geom_errorbar` function to display the intervals in the following example.


```{r}
data_KoF_processed %>%  
  # drop unused factor levels
  droplevels() %>% 
  # get means and 95% bootstrapped CIs for each condition
  group_by(condition) %>%
  nest() %>% 
  summarise(
    CIs = map(data, function(d) bootstrapped_CI(d$response == "TRUE"))
  ) %>% 
  unnest(CIs) %>% 
  # plot means and CIs
  ggplot(aes(x = condition, y = mean, fill = condition)) + 
  geom_col() +
  geom_errorbar(aes(ymin = lower, ymax = upper, width = 0.2)) +
  ylim(0,1) +
  ylab("") + xlab("") + ggtitle("Proportion of 'TRUE' responses per condition") +
  theme(legend.position = "none") +
  scale_fill_manual(values = project_colors)
```

<!-- exercise 2 -->
<div class = "exercises">
**Exercise E.2: Create a barplot**

First, we need to load the data set, like so: 

```{r}
url_prefix <- "https://raw.githubusercontent.com/michael-franke/intro-data-analysis/master/data_sets/"
WHO_data_url  <- str_c(url_prefix, "WHO.csv")
dataWHO <- read_csv(WHO_data_url)

```
Take a look at the data set first, in order to get familiar with it. 

Create a bar plot, in which the Region is on the x-axis and LifeExpectancy is on the y-axis. Each bar should represent the mean value of LifeExpectancy for each Region. 

<div class="collapsibleSolution">
<button class="trigger">Solution</button>
<div class="content">
A possible solution would be this:

```{r}
dataWHO %>%
  select( Region, LifeExpectancy) %>% 
  group_by(Region) %>% 
  summarise(
    LifeExpectancy_mean= mean(LifeExpectancy)
  ) %>%
 ggplot(aes(
   x = Region, 
   y = LifeExpectancy_mean, 
   fill = Region)) +
  geom_col() 

```

</div>
</div>
</div>

### Plotting distributions: histograms, boxplots, densities and violins

There are different ways for plotting the distribution of observations in a one-dimensional vector, each with its own advantages and disadvantages: the histogram, a box plot, a density plot, and a violin plot. Let's have a look at each, based on the `average_price` of different types of avocados.

The histogram displays the number of occurrences of observations inside of prespecified bins. By default the function `geom_histogram` uses 30 equally spaced bins to display counts of your observations.

```{r}
avocado_data %>% 
  ggplot(aes(x = average_price)) +
  geom_histogram()
```

If we specify more bins, we get a more fine-grained picture. (But notice that such a high number of bins works for the present data set, which has many observations, but it would not necessarily for a small data set.)

```{r}
avocado_data %>% 
  ggplot(aes(x = average_price)) +
  geom_histogram(bins = 75)
```

We can also layer histograms but this is usually a bad idea (even if we tinker with opacity) because a higher layer might block important information from a lower layer:

```{r}
avocado_data %>% 
  ggplot(aes(x = average_price, fill = type)) +
  geom_histogram(bins = 75)
```

An alternative display of distributional metric information is a **box plot**. Box plots are classics, also called *box-and-whiskers plots*, and they basically visually report key summary statistics of your metric data. These do work much better than histograms for direct comparison:

```{r}
avocado_data %>% 
  ggplot(aes(x = type , y = average_price)) +
  geom_boxplot()
```

What we see here is the median for each group (thick black line) and the 25% and 75% quantiles (boxes). The straight lines show the range from the 25% or 75% quantiles to the values given by median + 1.58 * IQR / sqrt(n), where the IQR is the "interquartile range", i.e., the range between the 25% and 75% quantiles (boxes).


To get a better picture of the shape of the distritbuion, `geom_density` uses a kernel estimate to show a smoothed line, roughly indicating ranges of higher density of observations with higher numbers. Using opacity, `geom_density` is useful also for the close comparison of distributions across different groups:

```{r}
avocado_data %>% 
  ggplot(aes(x = average_price, color = type, fill = type)) +
  geom_density(alpha = 0.5)
```

For many groups to compare, density plots can become cluttered. **Violin plots** are like mirrored density plots and are better for comparison of multiple groups:

```{r}
avocado_data %>% 
  ggplot(aes(x = type, y= average_price, fill = type)) +
  geom_violin(alpha = 0.5)
```

A frequently seen method of visualization is to layer a jittered distribution of points under a violin plot, like so:

```{r}
avocado_data %>% 
  ggplot(aes(x = type, y= average_price, fill = type)) +
  geom_jitter(alpha = 0.3, width = 0.2) +
  geom_violin(alpha = 0.5) 
```

### Rugs

Since plotting distributions, especially with high-level abstract smoothing as in `geom_density` and `geom_violin` fails to give information about the actual quantity of the data points, rug plots are useful additions to such plots. `geom_rug` add marks along the axes where different points lie.

Here is an example of `geom_rug` combined with `geom_density`:

```{r}
avocado_data %>% 
  filter(type == "organic") %>% 
  ggplot(aes(x = average_price)) +
  geom_density(fill = "darkorange", alpha = 0.5) +
  geom_rug()
```


Here are rugs on a two-dimensional scatter plot:

```{r}
avocado_data %>% 
  filter(type == "conventional") %>% 
  ggplot(aes(x = total_volume_sold, y = average_price)) +
  geom_point(alpha = 0.3) +
  geom_rug(alpha = 0.2)
```

### Annotation

It can be useful to add further elements to a plot. We might want to add text, or specific geometrical shapes to highlight aspects of data. The most general function for doing this is `annotate`. The function `annotate` takes as a first argument a `geom` argument, e.g., `text` or `rectangle`. It is therefore not a wrapper function in the `geom_` family of functions, but the underlying function around which connvenience functions like `geom_text` or `geom_rectangle` are wrapped. The further arguments that `annotate` expects depend on the geom it is supposed to realize. 

Suppose we want to add textual information at a particular coordinate. We can do this with `annotate` as follows:

```{r}
avocado_data %>% 
  filter(type == "conventional") %>% 
  ggplot(aes(x = total_volume_sold, y = average_price)) +
  geom_point(alpha = 0.2) +
  annotate(
    geom = "text", 
    # x and y coordinates for the text
    x = 2e7,
    y = 2,
    # text to be displayed
    label = "Bravo avocado!",
    color = "firebrick",
    size = 8
  )
```

We can also single out some data points, like so:

```{r}
avocado_data %>% 
  filter(type == "conventional") %>% 
  ggplot(aes(x = total_volume_sold, y = average_price)) +
  geom_point(alpha = 0.2) +
  annotate(
    geom = "rect", 
    # coordinates for the rectangle
    xmin = 2.1e7,
    xmax = max(avocado_data$total_volume_sold) + 100,
    ymin = 0.7,
    ymax = 1.7,
    color = "firebrick",
    alpha = 0,
    size = 2
  )
```

## Faceting {#Chap-02-04-faceting}

If we have grouping information, sometimes it can just get too much to put all of the information in a single plot, even if we use colors, shapes or linetypes for disambiguation. Facets are a great way to seperately repeat the same kind of plot for different levels of relevant factors. 

The functions `facet_grid` and `facet_wrap` are used for faceting. They both expect a formula-like syntax (we have not yet introduced formulas) using the notation `~` to separate factors. The difference between these functions shows most clearly when we have more than two factors. So let's introduce a new factor `early` to the avocado price data, representing whether a recorded measurement was no later than the median date or not. 

```{r}
avocado_data_early_late <- avocado_data %>% 
  mutate(early = ifelse(Date <= median(Date), "early", "late"))
```

Using `facet_grid` we get a two-dimensional grid, and we can specify along which axis of this grid the different factor levels are to range by putting the factors in the formula notation like this: `row_factor ~ col_factor`.

```{r}
avocado_data_early_late %>% 
  ggplot(aes(x = log(total_volume_sold), y = average_price)) +
  geom_point(alpha = 0.3, color = "skyblue") +
  geom_smooth(method = "lm", color = "darkorange") +
  facet_grid(type ~ early)
```

The same kind of plot realized with `facet_wrap` looks slightly different. The different factor level combinations are mushed together into a pair.

```{r}
avocado_data_early_late %>% 
  ggplot(aes(x = log(total_volume_sold), y = average_price)) +
  geom_point(alpha = 0.3, color = "skyblue") +
  geom_smooth(method = "lm", color = "darkorange") +
  facet_wrap(type ~ early)
```

<!-- exercise 3 -->
<div class = "exercises">
**Exercise E.3: Faceting**

In you own words, describe what each line of the both codes above do:  

<div class="collapsibleSolution">
<button class="trigger">Solution</button>
<div class="content">

For both: 
1. Defining which information should be placed on which axes. 
2.A scatter plot is created using geom point to show data points. Furthermore, the alpha level is chosen and the color of the points is skyblue. 
3.A line is added using `geom_smooth` and the method `lm`. The color of the line is dark orange. 
4. Both `geom-point` and `geom_smooth` are currently following the mapping given at the beginning

`facet_grid`:
5. Now the grid is created with `facet_grid`, which divides the plot into type and time (early or late). In each part of the plot you now see the subplot, which contains only the data points that belong to the respective combination.Type and time are placed on different axes.  

`facet_wrap`:
5. Now the grid is created with `facet_grid`, which divides the plot into type and time (early or late). In each part of the plot you now see the subplot, which contains only the data points that belong to the respective combination. Here type and time are combined into pairs. 
</div>
</div>

</div>
With facet_wrap it is possible to specify the desired number of columns or rows:

```{r}
avocado_data_early_late %>% 
  ggplot(aes(x = log(total_volume_sold), y = average_price)) +
  geom_point(alpha = 0.3, color = "skyblue") +
  geom_smooth(method = "lm", color = "darkorange") +
  facet_wrap(type ~ early, nrow = 1)
```




## Customization etc. {#Chap-02-04-customization}

There are many ways in which graphs can (and often: ought to) be tweaked further. The following can only cover a small, but hopefully useful selection.

### Themes 

The general appearance of a plot is governed by its **theme**. There are many ready-made themes already in the `ggplot` package, as listed [here](https://ggplot2.tidyverse.org/reference/ggtheme.html), and there are more in several other packages. If we store a plot in a variable we can look at how different themes affect it.

```{r}
avocado_grid_plot <- avocado_data_early_late %>% 
  ggplot(aes(x = log(total_volume_sold), y = average_price)) +
  geom_point(alpha = 0.3, color = "skyblue") +
  geom_smooth(method = "lm", color = "darkorange") +
  facet_grid(type ~ early)
```


```{r}
avocado_grid_plot + theme_classic()
```

```{r}
avocado_grid_plot + theme_void()
```


```{r}
avocado_grid_plot + theme_dark()
```

The plots in this book use the theme `hrbrthemes::theme_ipsum` from the `hrbrthemes` package as a default. You can set the default theme for all subsequent plots using a command like this:

```{r, eval = F}
# set the 'void' theme as global default
theme_set(
  theme_void()
)
```


More elaborate tweaking of a plot's layout can be achieved by the `theme` function. There are [many options](https://ggplot2.tidyverse.org/reference/theme.html). Some let you do crazy things:

```{r}
avocado_grid_plot + theme(plot.background = element_rect(fill = "darkgreen"))
```

### Guides

When using grouped variables (by color, shape, linetype, group, ...) `ggplot` creates a legend automatically.

```{r}
avocado_data %>% 
  ggplot(
    mapping = aes(
      x = log(total_volume_sold), 
      y = average_price, 
      color = type
    )
  ) +
  geom_point(alpha = 0.5)
```

The legend can be suppressed with the `guides` command. It takes as arguments the different types of grouping variables (like `color`, `group`, etc,)

```{r}
avocado_data %>% 
  ggplot(
    mapping = aes(
      x = log(total_volume_sold), 
      y = average_price, 
      color = type
    )
  ) +
  geom_point(alpha = 0.5) +
  # no legend for grouping by color
  guides(color = "none")
```

### Axes, ticks and tick labels

If you need to use a non-standard (Cartesian) axis, you can do so, e.g., to change the $x$-axis to a log scale (with base 10):

```{r}
avocado_data %>% 
  ggplot(
    mapping = aes(
      x = total_volume_sold, 
      y = average_price, 
      color = type
    )
  ) +
  geom_point(alpha = 0.5) +
  scale_x_log10()
```


The `scales` package has a number of nice convenience functions for tweaking axis ticks (the places where axes are marked and possibly labelled) and tick labels (the labels applied to the tick marks). For example, we can add dollar signs to the price information, like so:

```{r}
avocado_data %>% 
  ggplot(
    mapping = aes(
      x = total_volume_sold, 
      y = average_price, 
      color = type
    )
  ) +
  geom_point(alpha = 0.5) +
  scale_x_log10() +
  scale_y_continuous(labels = scales::dollar)
```


### Labels

To change any other kind of labeling information (aside from tick mark labels on axes), the `labs` function can be used. It is rather self-explanatory:

```{r}
avocado_data %>% 
  ggplot(
    mapping = aes(
      x = total_volume_sold, 
      y = average_price, 
      color = type
    )
  ) +
  geom_point(alpha = 0.5) +
  scale_x_log10() +
  scale_y_continuous(labels = scales::dollar) +
    # change axis labels and plot title & subtitle
  labs(
    x = 'Total volume sold (on a log scale)',
    y = 'Average price',
    title = "Avocado prices plotted against the amount sold per type",
    subtitle = "With linear regression lines",
    caption = "This plot shows the total volume of avocados sold against the average price for many different points in time."
  )
```

### Combining & arranging plots

Presenting visual information in a tightly packed spatial arrangement can be helpful for the spectator. Everything is within a single easy saccade, so to speak. Therefore it can be useful to combine different plots into a single combined plot. The `cowplot` package helps with this, in particular the function `cowplot::plot_grid` as shown here:

```{r}
# create an avocado plot
avocado_plot <- avocado_data %>% 
  ggplot(aes(x = total_volume_sold, y = average_price)) +
  geom_point(alpha = 0.5)

# create a BLJM bar plot
BLJM_plot <- data_BLJM_processed %>% 
  ggplot(aes(x = response)) +
  geom_bar()

# combine both into one
cowplot::plot_grid(
  # plots to combine
  avocado_plot, 
  BLJM_plot,
  # number columns
  ncol = 1
  )
```

### LaTeX expressions in plot labels

If you are enthusiastic about LaTeX, you can also use it inside of plot labels. The `latex2exp` package is useful here, which provides the function `latex2exp::TeX` to allow you to include LaTeX formulas. Just make sure that you double all backslashes, as in the following example:

```{r}
avocado_data %>%
  ggplot(aes(x = total_volume_sold, y = average_price)) +
  geom_point(alpha = 0.5) +
  labs(title = latex2exp::TeX("We can use $\\LaTeX$ here: $\\sum_{i = 0}^n \\alpha^i$"))
```

<!-- exercise 4 -->
<div class = "exercises">
**Exercise E.4: Customization**

Feel free to play around with customising your previously created plots or plots that you find in this book. Try to make annotations or try out different themes and colours. It will help you understand these kinds of plots a little better
</div>